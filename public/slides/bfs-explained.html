<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>BFS - Breadth-First Search | CS205 Data Structures</title>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: 'Segoe UI', system-ui, -apple-system, sans-serif; background: #0f172a; color: #e2e8f0; }
.slide { display: none; min-height: 100vh; padding: 40px 60px; position: relative; }
.slide.active { display: flex; flex-direction: column; justify-content: center; }
.slide-number { position: absolute; bottom: 20px; right: 40px; color: #64748b; font-size: 14px; }
.nav { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 12px; z-index: 100; }
.nav button { background: #334155; border: 1px solid #475569; color: #e2e8f0; padding: 8px 20px; border-radius: 8px; cursor: pointer; font-size: 14px; transition: all 0.2s; }
.nav button:hover { background: #475569; }
.nav button:disabled { opacity: 0.3; cursor: not-allowed; }
.progress { position: fixed; top: 0; left: 0; height: 3px; background: linear-gradient(90deg, #3b82f6, #8b5cf6); transition: width 0.3s; z-index: 100; }
h1 { font-size: 2.8em; margin-bottom: 20px; background: linear-gradient(135deg, #3b82f6, #8b5cf6); -webkit-background-clip: text; -webkit-text-fill-color: transparent; line-height: 1.2; }
h2 { font-size: 2em; margin-bottom: 16px; color: #93c5fd; }
h3 { font-size: 1.4em; margin-bottom: 12px; color: #a5b4fc; }
p, li { font-size: 1.15em; line-height: 1.7; color: #cbd5e1; margin-bottom: 10px; }
.subtitle { font-size: 1.3em; color: #94a3b8; margin-bottom: 30px; }
.two-col { display: grid; grid-template-columns: 1fr 1fr; gap: 40px; align-items: start; }
.center { text-align: center; }
.mt { margin-top: 20px; }
.diagram { background: #1e293b; border: 1px solid #334155; border-radius: 12px; padding: 24px; font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace; font-size: 1em; line-height: 1.6; white-space: pre; overflow-x: auto; margin: 16px 0; color: #a5f3fc; }
.diagram.small { font-size: 0.85em; }
.key-idea { background: linear-gradient(135deg, rgba(59,130,246,0.15), rgba(139,92,246,0.15)); border-left: 4px solid #3b82f6; border-radius: 0 12px 12px 0; padding: 20px 24px; margin: 16px 0; }
.key-idea h3 { margin-bottom: 8px; }
.warning { background: rgba(245,158,11,0.12); border-left: 4px solid #f59e0b; border-radius: 0 12px 12px 0; padding: 20px 24px; margin: 16px 0; }
.warning h3 { color: #fbbf24; }
.analogy { background: rgba(16,185,129,0.12); border-left: 4px solid #10b981; border-radius: 0 12px 12px 0; padding: 20px 24px; margin: 16px 0; }
.analogy h3 { color: #34d399; }
table { border-collapse: collapse; margin: 16px 0; width: auto; }
th, td { border: 1px solid #475569; padding: 10px 16px; text-align: center; }
th { background: #334155; color: #93c5fd; font-weight: 600; }
td { background: #1e293b; color: #e2e8f0; }
tr.highlight td { background: rgba(59,130,246,0.2); }
.fade-in { animation: fadeIn 0.5s ease-in; }
@keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
ul { padding-left: 24px; }
ul li { margin-bottom: 8px; }
code { background: #1e293b; padding: 2px 8px; border-radius: 4px; font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace; color: #a5f3fc; font-size: 0.95em; }
.tag { display: inline-block; background: #334155; color: #93c5fd; padding: 4px 12px; border-radius: 20px; font-size: 0.85em; margin-right: 8px; margin-bottom: 6px; }
.visited { color: #34d399; font-weight: bold; }
.current { color: #fbbf24; font-weight: bold; }
.unvisited { color: #64748b; }
</style>
</head>
<body>

<div class="progress" id="progress"></div>

<!-- ==================== SLIDE 1: Title ==================== -->
<div class="slide active" id="slide-1">
  <div class="center" style="width:100%;">
    <h1 style="font-size:3.4em; margin-bottom:10px;">BFS - Breadth-First Search</h1>
    <p class="subtitle" style="font-size:1.5em; margin-bottom: 40px;">Explore a graph level by level</p>
    <div class="diagram" style="display:inline-block; text-align:left; font-size:0.95em;">
         [A]---[B]---[E]
          |     |     |
         [C]---[D]---[F]
          |           |
         [G]---------[H]

   Level 0:  A
   Level 1:  B, C
   Level 2:  D, E, G
   Level 3:  F, H
    </div>
    <div style="margin-top:30px;">
      <span class="tag">CS205 Data Structures</span>
      <span class="tag">Graph Algorithms</span>
      <span class="tag">Shortest Paths</span>
    </div>
  </div>
  <div class="slide-number">1 / 18</div>
</div>

<!-- ==================== SLIDE 2: What is BFS? ==================== -->
<div class="slide" id="slide-2">
  <h2>What is BFS?</h2>
  <p class="subtitle">Exploring a graph one layer at a time</p>

  <div class="two-col">
    <div>
      <p>Breadth-First Search starts at a <strong>source vertex</strong> and explores the graph in expanding rings:</p>
      <ul class="mt">
        <li>First, visit <strong>all neighbors</strong> of the source (distance 1)</li>
        <li>Then, visit all <strong>neighbors of neighbors</strong> (distance 2)</li>
        <li>Then distance 3, 4, 5 ... until the entire reachable graph is explored</li>
      </ul>

      <div class="analogy">
        <h3>Analogy: Ripples in a Pond</h3>
        <p>Drop a stone into still water. The ripples expand outward in concentric circles. BFS works exactly the same way -- it radiates outward from the source, reaching everything at distance <em>k</em> before anything at distance <em>k+1</em>.</p>
      </div>
    </div>
    <div>
      <div class="diagram">
  Source = A

         [<span class="current">A</span>]---[B]---[E]       Level 0: A
          |     |     |
         [C]---[D]---[F]       Level 1: B, C
          |           |
         [G]---------[H]       Level 2: D, E, G

                               Level 3: F, H

  ~~~~ Ripple 0 ~~~~  A
  ~~~~~ Ripple 1 ~~~~ B, C
  ~~~~~~ Ripple 2 ~~~ D, E, G
  ~~~~~~~ Ripple 3 ~~ F, H
      </div>
    </div>
  </div>

  <div class="key-idea">
    <h3>Key Idea</h3>
    <p>BFS guarantees that when you first reach a vertex, you have found the <strong>shortest path</strong> (in terms of number of edges) from the source to that vertex.</p>
  </div>
  <div class="slide-number">2 / 18</div>
</div>

<!-- ==================== SLIDE 3: BFS Uses a Queue ==================== -->
<div class="slide" id="slide-3">
  <h2>BFS Uses a Queue</h2>
  <p class="subtitle">FIFO ordering is the secret ingredient</p>

  <div class="two-col">
    <div>
      <h3>Two Key Data Structures</h3>
      <ul>
        <li><strong>Queue (FIFO)</strong> -- holds vertices waiting to be explored. First in, first out ensures level-by-level order.</li>
        <li><strong>Visited set (or boolean array)</strong> -- prevents revisiting vertices and infinite loops in cyclic graphs.</li>
      </ul>

      <div class="key-idea mt">
        <h3>Why a Queue?</h3>
        <p>A queue processes vertices in the <strong>order they were discovered</strong>. All level-1 vertices are enqueued before any level-2 vertices, so level-1 is fully processed first. This is what makes it "breadth-first."</p>
      </div>

      <div class="warning mt">
        <h3>Warning: Stack != BFS</h3>
        <p>If you replace the queue with a stack, you get <strong>DFS</strong> (Depth-First Search), which goes deep before going wide. The data structure choice is the fundamental difference.</p>
      </div>
    </div>
    <div>
      <h3>Pseudocode Overview</h3>
      <div class="diagram small">
BFS(graph, source):
  create empty Queue Q
  create empty Set visited

  Q.enqueue(source)
  visited.add(source)

  while Q is not empty:
      u = Q.dequeue()
      process(u)            // e.g., print u

      for each neighbor v of u:
          if v not in visited:
              visited.add(v)
              Q.enqueue(v)
      </div>

      <div class="diagram small" style="margin-top:12px;">
  Queue behavior (FIFO):

  enqueue -->  [ D | C | B | A ]  --> dequeue
               back            front

  Dequeue returns A first (earliest discovered)
      </div>
    </div>
  </div>
  <div class="slide-number">3 / 18</div>
</div>

<!-- ==================== SLIDE 4: BFS Algorithm (Detailed) ==================== -->
<div class="slide" id="slide-4">
  <h2>BFS Algorithm -- Detailed</h2>
  <p class="subtitle">With distance and parent tracking</p>

  <div class="two-col">
    <div>
      <div class="diagram small">
BFS(graph, source):

  // --- INITIALIZATION ---
  for each vertex v in graph:
      dist[v]   = INFINITY    // unknown distance
      parent[v] = NULL        // no parent yet
      color[v]  = WHITE       // unvisited

  dist[source]   = 0
  color[source]  = GRAY       // discovered
  parent[source] = NULL

  Q = empty queue
  Q.enqueue(source)

  // --- MAIN LOOP ---
  while Q is not empty:
      u = Q.dequeue()

      for each neighbor v of u:
          if color[v] == WHITE:      // unvisited?
              color[v]  = GRAY       // mark discovered
              dist[v]   = dist[u] + 1
              parent[v] = u
              Q.enqueue(v)

      color[u] = BLACK               // fully explored
      </div>
    </div>
    <div>
      <h3>Color Scheme (CLRS convention)</h3>
      <table style="width:100%;">
        <tr><th>Color</th><th>Meaning</th></tr>
        <tr><td><span style="color:#64748b;">WHITE</span></td><td>Undiscovered</td></tr>
        <tr><td><span style="color:#fbbf24;">GRAY</span></td><td>Discovered, in the queue</td></tr>
        <tr><td><span style="color:#34d399;">BLACK</span></td><td>Fully explored (dequeued)</td></tr>
      </table>

      <h3 class="mt">What Each Array Stores</h3>
      <table style="width:100%;">
        <tr><th>Array</th><th>Purpose</th></tr>
        <tr><td><code>dist[v]</code></td><td>Shortest distance from source to v</td></tr>
        <tr><td><code>parent[v]</code></td><td>Predecessor of v on shortest path</td></tr>
        <tr><td><code>color[v]</code></td><td>Visit status (WHITE/GRAY/BLACK)</td></tr>
      </table>

      <div class="key-idea mt">
        <h3>Key Idea</h3>
        <p>We mark a vertex as <strong>discovered (GRAY) when we enqueue it</strong>, not when we dequeue it. This prevents the same vertex from being enqueued multiple times.</p>
      </div>
    </div>
  </div>
  <div class="slide-number">4 / 18</div>
</div>

<!-- ==================== SLIDE 5: Step-by-Step Example 1 ==================== -->
<div class="slide" id="slide-5">
  <h2>BFS Step-by-Step Example</h2>
  <p class="subtitle">Source = A on the following graph</p>

  <div class="two-col">
    <div>
      <h3>The Graph</h3>
      <div class="diagram">
        [A]----[B]
        / \      \
      [C]  [D]   [E]
       |    |   / |
      [F]  [G]   [H]

  Adjacency lists (alphabetical):
  A: B, C, D
  B: A, E
  C: A, F
  D: A, G
  E: B, G, H
  F: C
  G: D, E
  H: E
      </div>
    </div>
    <div>
      <h3>Step 0: Initialize</h3>
      <div class="diagram small">
  Enqueue source A, mark visited.

  Graph:
        [<span class="current">A</span>]----[B]
        / \      \
      [C]  [D]   [E]
       |    |   / |
      [F]  [G]   [H]

  Queue:   [ A ]
  Visited: { A }
  Dist:    A=0
      </div>

      <h3>Step 1: Dequeue A, explore neighbors</h3>
      <div class="diagram small">
  Dequeue A. Neighbors: B, C, D
  All unvisited --> enqueue all.

  Graph:     <span class="visited">[A]</span>----[<span class="current">B</span>]
             / \      \
           [<span class="current">C</span>]  [<span class="current">D</span>]   [E]
            |    |   / |
           [F]  [G]   [H]

  Queue:   [ B, C, D ]
  Visited: { A, B, C, D }
  Dist:    A=0  B=1  C=1  D=1
      </div>
    </div>
  </div>
  <div class="slide-number">5 / 18</div>
</div>

<!-- ==================== SLIDE 6: Step-by-Step (continued) ==================== -->
<div class="slide" id="slide-6">
  <h2>BFS Step-by-Step (continued)</h2>
  <p class="subtitle">Processing level 1 vertices</p>

  <div class="two-col">
    <div>
      <h3>Step 2: Dequeue B, explore neighbors</h3>
      <div class="diagram small">
  Dequeue B. Neighbors: A, E
  A already visited. E is new --> enqueue E.

  Graph:     <span class="visited">[A]</span>----<span class="visited">[B]</span>
             / \      \
           [<span class="current">C</span>]  [<span class="current">D</span>]   [<span class="current">E</span>]
            |    |   / |
           [F]  [G]   [H]

  Queue:   [ C, D, E ]
  Visited: { A, B, C, D, E }
  Dist:    A=0  B=1  C=1  D=1  E=2
      </div>

      <h3>Step 3: Dequeue C, explore neighbors</h3>
      <div class="diagram small">
  Dequeue C. Neighbors: A, F
  A already visited. F is new --> enqueue F.

  Graph:     <span class="visited">[A]</span>----<span class="visited">[B]</span>
             / \      \
           <span class="visited">[C]</span>  [<span class="current">D</span>]   [<span class="current">E</span>]
            |    |   / |
           [<span class="current">F</span>]  [G]   [H]

  Queue:   [ D, E, F ]
  Visited: { A, B, C, D, E, F }
  Dist:    A=0  B=1  C=1  D=1  E=2  F=2
      </div>
    </div>
    <div>
      <h3>Step 4: Dequeue D, explore neighbors</h3>
      <div class="diagram small">
  Dequeue D. Neighbors: A, G
  A already visited. G is new --> enqueue G.

  Graph:     <span class="visited">[A]</span>----<span class="visited">[B]</span>
             / \      \
           <span class="visited">[C]</span>  <span class="visited">[D]</span>   [<span class="current">E</span>]
            |    |   / |
           [<span class="current">F</span>]  [<span class="current">G</span>]   [H]

  Queue:   [ E, F, G ]
  Visited: { A, B, C, D, E, F, G }
  Dist:    A=0 B=1 C=1 D=1 E=2 F=2 G=2
      </div>

      <h3>Step 5: Dequeue E, explore neighbors</h3>
      <div class="diagram small">
  Dequeue E. Neighbors: B, G, H
  B visited. G visited. H is new --> enqueue H.

  Graph:     <span class="visited">[A]</span>----<span class="visited">[B]</span>
             / \      \
           <span class="visited">[C]</span>  <span class="visited">[D]</span>   <span class="visited">[E]</span>
            |    |   / |
           [<span class="current">F</span>]  [<span class="current">G</span>]   [<span class="current">H</span>]

  Queue:   [ F, G, H ]
  Visited: { A, B, C, D, E, F, G, H }
  Dist:    A=0 B=1 C=1 D=1 E=2 F=2 G=2 H=3
      </div>
    </div>
  </div>
  <div class="slide-number">6 / 18</div>
</div>

<!-- ==================== SLIDE 7: Step-by-Step (final) ==================== -->
<div class="slide" id="slide-7">
  <h2>BFS Step-by-Step (final)</h2>
  <p class="subtitle">Processing level 2 and level 3 vertices</p>

  <div class="two-col">
    <div>
      <h3>Step 6: Dequeue F</h3>
      <div class="diagram small">
  Dequeue F. Neighbors: C
  C already visited. Nothing to enqueue.

  Queue:   [ G, H ]
      </div>

      <h3>Step 7: Dequeue G</h3>
      <div class="diagram small">
  Dequeue G. Neighbors: D, E
  Both already visited. Nothing to enqueue.

  Queue:   [ H ]
      </div>

      <h3>Step 8: Dequeue H</h3>
      <div class="diagram small">
  Dequeue H. Neighbors: E
  E already visited. Nothing to enqueue.

  Queue:   [  ]   (EMPTY -- BFS complete!)
      </div>

      <div class="key-idea mt">
        <h3>Observation</h3>
        <p>The queue emptied naturally. Every reachable vertex was visited exactly once. Total dequeue operations = 8 (one per vertex).</p>
      </div>
    </div>
    <div>
      <h3>Final State</h3>
      <div class="diagram">
  All vertices visited (GREEN):

        <span class="visited">[A]</span>----<span class="visited">[B]</span>
        / \      \
      <span class="visited">[C]</span>  <span class="visited">[D]</span>   <span class="visited">[E]</span>
       |    |   / |
      <span class="visited">[F]</span>  <span class="visited">[G]</span>   <span class="visited">[H]</span>
      </div>

      <h3>BFS Tree (tree edges only)</h3>
      <div class="diagram">
            [A]             dist = 0
          / | \
        [B] [C] [D]        dist = 1
         |   |   |
        [E] [F] [G]        dist = 2
         |
        [H]                dist = 3
      </div>

      <h3>Distance & Parent Table</h3>
      <table style="width:100%;">
        <tr><th>Vertex</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th><th>G</th><th>H</th></tr>
        <tr><td><strong>Dist</strong></td><td>0</td><td>1</td><td>1</td><td>1</td><td>2</td><td>2</td><td>2</td><td>3</td></tr>
        <tr><td><strong>Parent</strong></td><td>--</td><td>A</td><td>A</td><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td></tr>
      </table>
    </div>
  </div>
  <div class="slide-number">7 / 18</div>
</div>

<!-- ==================== SLIDE 8: The BFS Tree ==================== -->
<div class="slide" id="slide-8">
  <h2>The BFS Tree</h2>
  <p class="subtitle">Tree edges vs. cross edges</p>

  <div class="two-col">
    <div>
      <h3>What Is the BFS Tree?</h3>
      <p>During BFS, each vertex (except the source) is discovered from exactly one other vertex. The edge used for that discovery is called a <strong>tree edge</strong>.</p>
      <p>All tree edges together form a <strong>spanning tree</strong> of the connected component -- the BFS tree.</p>

      <div class="diagram small">
  Original graph         BFS tree (source=A)

    [A]----[B]                 [A]
    / \      \               / | \
  [C]  [D]   [E]          [B] [C] [D]
   |    |   / |             |   |   |
  [F]  [G]   [H]          [E] [F] [G]
                            |
                           [H]
      </div>

      <div class="key-idea mt">
        <h3>Key Idea</h3>
        <p>The BFS tree encodes <strong>shortest paths</strong>. The path from any vertex back to the root in the BFS tree is the shortest path in the original graph.</p>
      </div>
    </div>
    <div>
      <h3>Edge Classification</h3>
      <table style="width:100%;">
        <tr><th>Edge Type</th><th>Definition</th><th>Example</th></tr>
        <tr><td><strong>Tree edge</strong></td><td>Used to discover a new vertex</td><td>A-B, A-C, A-D, B-E, C-F, D-G, E-H</td></tr>
        <tr><td><strong>Cross edge</strong></td><td>Connects vertices at same or adjacent levels, not used for discovery</td><td>D-G* already tree, C-A back, E-G cross</td></tr>
      </table>

      <div class="diagram small mt">
  Edges in original graph:

  Tree edges (solid):     Cross edges (dashed):
  A--B                    B----A  (back to parent)
  A--C                    E----G  (same level)
  A--D                    G----D  (back to parent)
  B--E                    F----C  (back to parent)
  C--F                    H----E  (back to parent)
  D--G
  E--H
      </div>

      <div class="warning mt">
        <h3>Important Property</h3>
        <p>In an <strong>undirected</strong> BFS, cross edges can only connect vertices whose levels differ by <strong>at most 1</strong>. There are no edges skipping levels.</p>
      </div>
    </div>
  </div>
  <div class="slide-number">8 / 18</div>
</div>

<!-- ==================== SLIDE 9: Shortest Paths ==================== -->
<div class="slide" id="slide-9">
  <h2>BFS Finds Shortest Paths (Unweighted)</h2>
  <p class="subtitle">Level = distance from source</p>

  <div class="two-col">
    <div>
      <h3>The Guarantee</h3>
      <p>In an <strong>unweighted graph</strong> (all edges have cost 1), BFS discovers every vertex at the <strong>minimum possible distance</strong> from the source.</p>

      <div class="diagram small">
  Source = A

  Distance 0:  A
  Distance 1:  B, C, D      (direct neighbors)
  Distance 2:  E, F, G      (2 hops away)
  Distance 3:  H             (3 hops away)

  Shortest path A-->H:
  A --> B --> E --> H   (length 3)
      </div>

      <h3 class="mt">Why Does This Work?</h3>
      <ol style="padding-left:24px;">
        <li>BFS processes vertices in <strong>non-decreasing order of distance</strong>.</li>
        <li>When we discover vertex <code>v</code> from vertex <code>u</code>, we set <code>dist[v] = dist[u] + 1</code>.</li>
        <li>Since <code>u</code> was dequeued first, <code>dist[u]</code> is already optimal.</li>
        <li>Therefore <code>dist[v]</code> is also optimal.</li>
      </ol>
    </div>
    <div>
      <h3>Proof Sketch (by contradiction)</h3>
      <div class="diagram small">
  Assume BFS does NOT give the shortest
  distance to some vertex v.

  Let d*(v) = true shortest distance.
  Let d(v)  = BFS-computed distance.

  Then d(v) > d*(v).

  But BFS sets d(v) = d(u) + 1 for some u
  where (u,v) is an edge.

  Since d(u) >= d*(u) and there exists a
  shortest path ending with edge (u',v)
  where d*(u') = d*(v) - 1:

  BFS must have discovered u' at distance
  <= d*(u') and thus v at distance
  <= d*(u') + 1 = d*(v).

  Contradiction: d(v) <= d*(v).
  Combined with d(v) >= d*(v), we get
  d(v) = d*(v).   QED
      </div>

      <div class="warning mt">
        <h3>Only Unweighted Graphs!</h3>
        <p>BFS does <strong>NOT</strong> find shortest paths in weighted graphs. For weighted graphs, use <strong>Dijkstra's algorithm</strong> (non-negative weights) or <strong>Bellman-Ford</strong> (negative weights allowed).</p>
      </div>
    </div>
  </div>
  <div class="slide-number">9 / 18</div>
</div>

<!-- ==================== SLIDE 10: Computing Distances ==================== -->
<div class="slide" id="slide-10">
  <h2>Computing Distances</h2>
  <p class="subtitle">dist[v] = dist[u] + 1 when discovering v from u</p>

  <div class="two-col">
    <div>
      <h3>Distance Computation Trace</h3>
      <div class="diagram small">
  Graph:
        [A]----[B]
        / \      \
      [C]  [D]   [E]
       |    |   / |
      [F]  [G]   [H]

  Source A: dist[A] = 0

  Discover B from A: dist[B] = 0 + 1 = 1
  Discover C from A: dist[C] = 0 + 1 = 1
  Discover D from A: dist[D] = 0 + 1 = 1

  Discover E from B: dist[E] = 1 + 1 = 2
  Discover F from C: dist[F] = 1 + 1 = 2
  Discover G from D: dist[G] = 1 + 1 = 2

  Discover H from E: dist[H] = 2 + 1 = 3
      </div>
    </div>
    <div>
      <h3>Key Code Fragment</h3>
      <div class="diagram small">
// When processing edge (u, v):
if not visited[v]:
    visited[v] = true
    <span style="color:#fbbf24;">dist[v] = dist[u] + 1</span>    // THIS LINE
    parent[v] = u
    queue.enqueue(v)
      </div>

      <h3 class="mt">Distance Array Evolution</h3>
      <table style="width:100%;">
        <tr><th>After processing</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th><th>G</th><th>H</th></tr>
        <tr><td>Init</td><td>0</td><td>&infin;</td><td>&infin;</td><td>&infin;</td><td>&infin;</td><td>&infin;</td><td>&infin;</td><td>&infin;</td></tr>
        <tr class="highlight"><td>Dequeue A</td><td>0</td><td>1</td><td>1</td><td>1</td><td>&infin;</td><td>&infin;</td><td>&infin;</td><td>&infin;</td></tr>
        <tr><td>Dequeue B</td><td>0</td><td>1</td><td>1</td><td>1</td><td>2</td><td>&infin;</td><td>&infin;</td><td>&infin;</td></tr>
        <tr><td>Dequeue C</td><td>0</td><td>1</td><td>1</td><td>1</td><td>2</td><td>2</td><td>&infin;</td><td>&infin;</td></tr>
        <tr class="highlight"><td>Dequeue D</td><td>0</td><td>1</td><td>1</td><td>1</td><td>2</td><td>2</td><td>2</td><td>&infin;</td></tr>
        <tr><td>Dequeue E</td><td>0</td><td>1</td><td>1</td><td>1</td><td>2</td><td>2</td><td>2</td><td>3</td></tr>
      </table>

      <div class="key-idea mt">
        <h3>Key Idea</h3>
        <p>Distances are computed <strong>as vertices are discovered</strong> (enqueued), not when they are processed (dequeued). Each vertex's distance is set exactly once and never changes.</p>
      </div>
    </div>
  </div>
  <div class="slide-number">10 / 18</div>
</div>

<!-- ==================== SLIDE 11: Reconstructing Shortest Path ==================== -->
<div class="slide" id="slide-11">
  <h2>Reconstructing the Shortest Path</h2>
  <p class="subtitle">Follow the parent pointers back to the source</p>

  <div class="two-col">
    <div>
      <h3>Parent Array</h3>
      <table style="width:100%;">
        <tr><th>Vertex</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th><th>G</th><th>H</th></tr>
        <tr><td><strong>parent</strong></td><td>--</td><td>A</td><td>A</td><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td></tr>
      </table>

      <h3 class="mt">Example: Path from A to H</h3>
      <div class="diagram small">
  Start at H.
  parent[H] = E   -->  path: H
  parent[E] = B   -->  path: E, H
  parent[B] = A   -->  path: B, E, H
  parent[A] = --  -->  path: A, B, E, H  (DONE)

  Shortest path: A --> B --> E --> H
  Distance: 3
      </div>

      <h3 class="mt">Example: Path from A to G</h3>
      <div class="diagram small">
  Start at G.
  parent[G] = D   -->  path: G
  parent[D] = A   -->  path: D, G
  parent[A] = --  -->  path: A, D, G  (DONE)

  Shortest path: A --> D --> G
  Distance: 2
      </div>
    </div>
    <div>
      <h3>Path Reconstruction Code</h3>
      <div class="diagram small">
function shortestPath(source, dest, parent):
    path = empty list
    current = dest

    // Trace back from dest to source
    while current != NULL:
        path.addFirst(current)   // prepend
        current = parent[current]

    // Check if path is valid
    if path[0] != source:
        return "No path exists"

    return path
      </div>

      <div class="diagram small mt">
  Visual: following parent pointers

  BFS Tree:
            [A]
          / | \
        [B] [C] [D]
         |   |   |
        [E] [F] [G]
         |
        [H]

  Path A-->H: go UP from H
        [<span class="visited">A</span>]
          |
        [<span class="visited">B</span>]
          |
        [<span class="visited">E</span>]
          |
        [<span class="visited">H</span>]
      </div>

      <div class="analogy mt">
        <h3>Analogy: Breadcrumb Trail</h3>
        <p>The parent array is like leaving breadcrumbs. Each vertex remembers who led it there. To find your way back to the source, just follow the breadcrumbs!</p>
      </div>
    </div>
  </div>
  <div class="slide-number">11 / 18</div>
</div>

<!-- ==================== SLIDE 12: BFS on Directed Graphs ==================== -->
<div class="slide" id="slide-12">
  <h2>BFS on Directed Graphs</h2>
  <p class="subtitle">Same algorithm, but only follow outgoing edges</p>

  <div class="two-col">
    <div>
      <h3>Directed Graph Example</h3>
      <div class="diagram">
  Source = A

  A ---> B ---> E
  |      |      |
  v      v      v
  C ---> D ---> F
         |
         v
         G

  Adjacency lists (outgoing only):
  A: B, C
  B: D, E
  C: D
  D: F, G
  E: F
  F: (none)
  G: (none)
      </div>

      <div class="warning mt">
        <h3>Direction Matters!</h3>
        <p>In a directed graph, edge A-->B does NOT mean you can go from B to A. BFS only follows <strong>outgoing</strong> edges from the current vertex.</p>
      </div>
    </div>
    <div>
      <h3>BFS Trace (source = A)</h3>
      <div class="diagram small">
  Step 0: Enqueue A
    Queue: [A]   Visited: {A}

  Step 1: Dequeue A. Out-neighbors: B, C
    Queue: [B, C]  Visited: {A, B, C}
    dist: A=0 B=1 C=1

  Step 2: Dequeue B. Out-neighbors: D, E
    Queue: [C, D, E]  Visited: {A,B,C,D,E}
    dist: D=2 E=2

  Step 3: Dequeue C. Out-neighbors: D
    D already visited. Skip.
    Queue: [D, E]

  Step 4: Dequeue D. Out-neighbors: F, G
    Queue: [E, F, G]  Visited: {A,B,C,D,E,F,G}
    dist: F=3 G=3

  Step 5: Dequeue E. Out-neighbors: F
    F already visited. Skip.
    Queue: [F, G]

  Step 6: Dequeue F. No out-neighbors.
    Queue: [G]

  Step 7: Dequeue G. No out-neighbors.
    Queue: []  DONE!
      </div>

      <h3>Result</h3>
      <table style="width:100%;">
        <tr><th>Vertex</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th><th>G</th></tr>
        <tr><td><strong>Dist</strong></td><td>0</td><td>1</td><td>1</td><td>2</td><td>2</td><td>3</td><td>3</td></tr>
        <tr><td><strong>Parent</strong></td><td>--</td><td>A</td><td>A</td><td>B</td><td>B</td><td>D</td><td>D</td></tr>
      </table>
    </div>
  </div>
  <div class="slide-number">12 / 18</div>
</div>

<!-- ==================== SLIDE 13: Connected Components ==================== -->
<div class="slide" id="slide-13">
  <h2>BFS for Connected Components</h2>
  <p class="subtitle">Finding all pieces of a disconnected graph</p>

  <div class="two-col">
    <div>
      <h3>Disconnected Graph</h3>
      <div class="diagram">
  Component 1      Component 2    Comp 3
  -----------      -----------    ------
  [A]---[B]        [E]---[F]      [H]
   |     |          |     |
  [C]---[D]        [G]---[I]
      </div>

      <h3 class="mt">Algorithm</h3>
      <div class="diagram small">
function findComponents(graph):
    components = 0
    visited = empty set

    for each vertex v in graph:
        if v not in visited:
            components += 1
            BFS(graph, v, visited)
            // BFS marks all reachable
            // vertices as visited

    return components
      </div>

      <p class="mt">Each BFS call explores one entire connected component. We count how many times we need to start a new BFS.</p>
    </div>
    <div>
      <h3>Trace</h3>
      <div class="diagram small">
  Pass 1: Start BFS from A
    Visits: A, B, C, D
    visited = {A, B, C, D}
    components = 1

  Skip B (visited), C (visited), D (visited)

  Pass 2: Start BFS from E
    Visits: E, F, G, I
    visited = {A, B, C, D, E, F, G, I}
    components = 2

  Skip F, G (visited)

  Pass 3: Start BFS from H
    Visits: H
    visited = {A, B, C, D, E, F, G, H, I}
    components = 3

  Skip I (visited)

  Result: <span style="color:#fbbf24;">3 connected components</span>
      </div>

      <div class="key-idea mt">
        <h3>Key Idea</h3>
        <p>A single BFS from one vertex explores <strong>only its connected component</strong>. To cover the entire graph, loop through all vertices and start a new BFS whenever you find an unvisited vertex.</p>
      </div>

      <div class="analogy mt">
        <h3>Analogy: Islands</h3>
        <p>Think of each component as an island. BFS explores one island completely. You need a new "boat trip" (new BFS) to reach each separate island.</p>
      </div>
    </div>
  </div>
  <div class="slide-number">13 / 18</div>
</div>

<!-- ==================== SLIDE 14: Time Complexity ==================== -->
<div class="slide" id="slide-14">
  <h2>Time Complexity: O(V + E)</h2>
  <p class="subtitle">Every vertex and every edge examined exactly once</p>

  <div class="two-col">
    <div>
      <h3>Why O(V + E)?</h3>
      <div class="diagram small">
  BFS main loop:

  while Q is not empty:         // runs V times
      u = Q.dequeue()           //   O(1) per call
      for each neighbor v of u: //   deg(u) neighbors
          if not visited[v]:    //   O(1) check
              ...               //   O(1) work

  Total iterations of inner loop:
  sum of deg(u) for all u = 2|E|  (undirected)
                           = |E|   (directed)

  Total work:
    V dequeues  +  O(E) neighbor checks
  = O(V + E)
      </div>

      <div class="key-idea mt">
        <h3>Why V + E, not V * E?</h3>
        <p>Each vertex is dequeued <strong>once</strong> (not E times). Each edge is checked <strong>once from each endpoint</strong> (undirected) or <strong>once total</strong> (directed). The work is <em>distributed</em> across vertices, not repeated.</p>
      </div>
    </div>
    <div>
      <h3>Concrete Example</h3>
      <div class="diagram small">
  Graph: V = 8, E = 9

        [A]----[B]
        / \      \
      [C]  [D]   [E]
       |    |   / |
      [F]  [G]   [H]

  Work done per vertex:
  Dequeue A: check 3 neighbors  (B,C,D)
  Dequeue B: check 2 neighbors  (A,E)
  Dequeue C: check 2 neighbors  (A,F)
  Dequeue D: check 2 neighbors  (A,G)
  Dequeue E: check 3 neighbors  (B,G,H)
  Dequeue F: check 1 neighbor   (C)
  Dequeue G: check 2 neighbors  (D,E)
  Dequeue H: check 1 neighbor   (E)
                                 --------
  Total neighbor checks:         16 = 2*8
  (but we have 9 edges,
   undirected so 2*9 = 18 adj entries)

  Total: 8 dequeues + 18 checks = O(V+E)
      </div>

      <h3 class="mt">Comparison</h3>
      <table style="width:100%;">
        <tr><th>Representation</th><th>BFS Time</th></tr>
        <tr><td>Adjacency List</td><td><strong>O(V + E)</strong> -- optimal</td></tr>
        <tr><td>Adjacency Matrix</td><td>O(V<sup>2</sup>) -- must scan each row</td></tr>
      </table>
    </div>
  </div>
  <div class="slide-number">14 / 18</div>
</div>

<!-- ==================== SLIDE 15: Space Complexity ==================== -->
<div class="slide" id="slide-15">
  <h2>Space Complexity: O(V)</h2>
  <p class="subtitle">Linear in the number of vertices</p>

  <div class="two-col">
    <div>
      <h3>Space Breakdown</h3>
      <table style="width:100%;">
        <tr><th>Data Structure</th><th>Space</th><th>Purpose</th></tr>
        <tr><td>Queue</td><td>O(V)</td><td>At most V vertices in queue</td></tr>
        <tr><td>Visited array</td><td>O(V)</td><td>One boolean per vertex</td></tr>
        <tr><td>Distance array</td><td>O(V)</td><td>One integer per vertex</td></tr>
        <tr><td>Parent array</td><td>O(V)</td><td>One pointer per vertex</td></tr>
        <tr><td><strong>Total</strong></td><td><strong>O(V)</strong></td><td></td></tr>
      </table>

      <div class="diagram mt">
  Memory layout:

  visited: [T][T][T][T][T][T][T][T]
            A  B  C  D  E  F  G  H

  dist:    [0][1][1][1][2][2][2][3]
            A  B  C  D  E  F  G  H

  parent:  [-][A][A][A][B][C][D][E]
            A  B  C  D  E  F  G  H

  Queue (max size during BFS): 3
  (when B, C, D were all in queue)
      </div>
    </div>
    <div>
      <h3>Queue Size Over Time</h3>
      <div class="diagram small">
  Queue size during our BFS example:

  Size
   4 |
   3 |    * * *
   2 |            * * *
   1 | *                * *
   0 |                       *
     +--+--+--+--+--+--+--+--+-->
       0  1  2  3  4  5  6  7  8
                Step

  Max queue size = 3
  (occurs when processing level 1)
      </div>

      <div class="warning mt">
        <h3>Worst Case Queue Size</h3>
        <p>In the worst case, the queue can hold <strong>O(V)</strong> vertices. Imagine a star graph where the center connects to all other V-1 vertices -- after processing the center, all V-1 neighbors are in the queue.</p>
      </div>

      <div class="diagram small mt">
  Star graph (worst case for queue):

       [B] [C] [D]
        \   |   /
         \  |  /
          [A]
         / | \
        /  |  \
      [E] [F] [G]

  After dequeuing A:
  Queue = [B, C, D, E, F, G]  (size V-1)
      </div>
    </div>
  </div>
  <div class="slide-number">15 / 18</div>
</div>

<!-- ==================== SLIDE 16: Social Network Application ==================== -->
<div class="slide" id="slide-16">
  <h2>Application: Social Network Distance</h2>
  <p class="subtitle">"Six degrees of separation"</p>

  <div class="two-col">
    <div>
      <h3>The Problem</h3>
      <p>Given a social network graph where vertices are people and edges are friendships, find the <strong>shortest friendship chain</strong> between two people.</p>

      <div class="diagram small">
  Social Network Graph:

  [Alice]---[Bob]---[Eve]
     |        |       |
  [Carol]  [Dave]  [Frank]
     |               |
  [Grace]-----------[Hank]

  Q: Shortest path from Alice to Frank?

  BFS from Alice:
  Level 0: Alice
  Level 1: Bob, Carol
  Level 2: Dave, Eve, Grace
  Level 3: Frank, Hank

  Answer: Alice->Bob->Eve->Frank (3 hops)
      </div>
    </div>
    <div>
      <div class="analogy">
        <h3>Six Degrees of Separation</h3>
        <p>The famous theory states that any two people on Earth are connected by at most 6 friendship links. BFS is how you'd actually <strong>verify</strong> this -- start from any person and measure BFS distances to everyone else.</p>
      </div>

      <h3 class="mt">Real-World Scale</h3>
      <div class="diagram small">
  Facebook (2016 study):
  - 1.59 billion users (vertices)
  - Average degree: ~338
  - Average distance: 3.57

  LinkedIn "degrees of connection":
  - 1st: direct connection
  - 2nd: friend of friend
  - 3rd: 3 hops away

  All computed using BFS variants!
      </div>

      <div class="key-idea mt">
        <h3>Key Idea</h3>
        <p>BFS naturally computes the "degree of separation" between any two people. This is the foundation for features like LinkedIn's "2nd connection" and Facebook's "mutual friends."</p>
      </div>
    </div>
  </div>
  <div class="slide-number">16 / 18</div>
</div>

<!-- ==================== SLIDE 17: More Applications ==================== -->
<div class="slide" id="slide-17">
  <h2>Applications: Web Crawling & Maze Solving</h2>
  <p class="subtitle">BFS is everywhere</p>

  <div class="two-col">
    <div>
      <h3>Web Crawling</h3>
      <p>A web crawler uses BFS to systematically discover web pages:</p>
      <div class="diagram small">
  Start: www.example.com

  Level 0: example.com
  Level 1: /about  /blog  /contact
  Level 2: /blog/post1  /blog/post2
  Level 3: /blog/post1/comments
  ...

  BFS ensures you discover all pages
  at distance k before going deeper.
  This gives a "breadth-first crawl."
      </div>

      <div class="key-idea mt">
        <h3>Why BFS for Crawling?</h3>
        <p>BFS finds pages <strong>close to the root</strong> first, which are usually the most important. DFS might get lost in deep, low-value chains of links.</p>
      </div>
    </div>
    <div>
      <h3>Maze Solving (Shortest Path)</h3>
      <div class="diagram small">
  Maze as a grid graph:

  S = Start, E = End, # = Wall

  +---+---+---+---+---+---+
  | <span class="visited">S</span> | <span class="visited">.</span> | <span class="visited">.</span> | # | . | . |
  +---+---+---+---+---+---+
  | # | # | <span class="visited">.</span> | # | . | . |
  +---+---+---+---+---+---+
  | . | . | <span class="visited">.</span> | <span class="visited">.</span> | <span class="visited">.</span> | # |
  +---+---+---+---+---+---+
  | . | # | # | # | <span class="visited">.</span> | . |
  +---+---+---+---+---+---+
  | . | . | . | . | <span class="visited">.</span> | <span class="visited">E</span> |
  +---+---+---+---+---+---+

  <span class="visited">Green</span> = BFS shortest path (9 steps)

  Each cell is a vertex.
  Edges connect adjacent non-wall cells.
  BFS finds the shortest path!
      </div>

      <div class="analogy mt">
        <h3>Analogy</h3>
        <p>Imagine flooding the maze with water from the start. The water expands one cell at a time in all directions. The first time water reaches the exit is the shortest path. That is BFS.</p>
      </div>
    </div>
  </div>
  <div class="slide-number">17 / 18</div>
</div>

<!-- ==================== SLIDE 18: Summary & Cheat Sheet ==================== -->
<div class="slide" id="slide-18">
  <h2>Summary & Cheat Sheet</h2>
  <p class="subtitle">Everything you need to know about BFS</p>

  <div class="two-col">
    <div>
      <h3>BFS Pseudocode</h3>
      <div class="diagram small">
BFS(graph, source):
    for each v in graph.vertices:
        dist[v] = INF
        parent[v] = NULL

    dist[source] = 0
    Q = new Queue()
    Q.enqueue(source)
    visited[source] = true

    while Q is not empty:
        u = Q.dequeue()
        for each neighbor v of u:
            if not visited[v]:
                visited[v] = true
                dist[v] = dist[u] + 1
                parent[v] = u
                Q.enqueue(v)
      </div>

      <h3 class="mt">Complexity</h3>
      <table style="width:100%;">
        <tr><th></th><th>Adj List</th><th>Adj Matrix</th></tr>
        <tr><td><strong>Time</strong></td><td>O(V + E)</td><td>O(V<sup>2</sup>)</td></tr>
        <tr><td><strong>Space</strong></td><td>O(V)</td><td>O(V)</td></tr>
      </table>
    </div>
    <div>
      <h3>When to Use BFS vs DFS</h3>
      <table style="width:100%;">
        <tr><th>Use BFS When...</th><th>Use DFS When...</th></tr>
        <tr><td>Shortest path (unweighted)</td><td>Topological sort</td></tr>
        <tr><td>Level-order traversal</td><td>Cycle detection</td></tr>
        <tr><td>Nearest neighbor search</td><td>Path existence check</td></tr>
        <tr><td>Connected components</td><td>Connected components</td></tr>
        <tr><td>Web crawling (breadth)</td><td>Maze generation</td></tr>
      </table>

      <div class="key-idea mt">
        <h3>Key Takeaways</h3>
        <ul>
          <li>BFS uses a <strong>queue</strong> (FIFO) to explore level by level</li>
          <li>It finds <strong>shortest paths in unweighted graphs</strong></li>
          <li>Mark vertices visited <strong>when enqueuing</strong>, not when dequeuing</li>
          <li>The BFS tree gives shortest paths via <strong>parent pointers</strong></li>
          <li>Time: <strong>O(V + E)</strong> -- linear in graph size</li>
        </ul>
      </div>

      <div class="warning mt">
        <h3>Common Pitfalls</h3>
        <ul>
          <li>Forgetting to mark source as visited before the loop</li>
          <li>Marking visited on dequeue instead of enqueue (causes duplicates)</li>
          <li>Using BFS on weighted graphs (use Dijkstra instead)</li>
        </ul>
      </div>
    </div>
  </div>
  <div class="slide-number">18 / 18</div>
</div>

<!-- ==================== NAVIGATION ==================== -->
<div class="nav">
  <button id="prevBtn" onclick="changeSlide(-1)">&larr; Prev</button>
  <button id="nextBtn" onclick="changeSlide(1)">Next &rarr;</button>
</div>

<script>
let currentSlide = 1;
const totalSlides = 18;

function showSlide(n) {
  // Clamp
  if (n < 1) n = 1;
  if (n > totalSlides) n = totalSlides;
  currentSlide = n;

  // Hide all slides
  document.querySelectorAll('.slide').forEach(s => {
    s.classList.remove('active');
    s.classList.remove('fade-in');
  });

  // Show target slide
  const target = document.getElementById('slide-' + n);
  target.classList.add('active');
  target.classList.add('fade-in');

  // Update progress bar
  document.getElementById('progress').style.width = ((n / totalSlides) * 100) + '%';

  // Update button states
  document.getElementById('prevBtn').disabled = (n === 1);
  document.getElementById('nextBtn').disabled = (n === totalSlides);

  // Update URL hash
  history.replaceState(null, null, '#slide-' + n);
}

function changeSlide(delta) {
  showSlide(currentSlide + delta);
}

// Keyboard navigation
document.addEventListener('keydown', function(e) {
  if (e.key === 'ArrowRight' || e.key === 'ArrowDown' || e.key === ' ') {
    e.preventDefault();
    changeSlide(1);
  } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
    e.preventDefault();
    changeSlide(-1);
  } else if (e.key === 'Home') {
    e.preventDefault();
    showSlide(1);
  } else if (e.key === 'End') {
    e.preventDefault();
    showSlide(totalSlides);
  }
});

// Touch swipe support
let touchStartX = 0;
let touchEndX = 0;

document.addEventListener('touchstart', function(e) {
  touchStartX = e.changedTouches[0].screenX;
}, false);

document.addEventListener('touchend', function(e) {
  touchEndX = e.changedTouches[0].screenX;
  const diff = touchStartX - touchEndX;
  if (Math.abs(diff) > 50) {
    if (diff > 0) changeSlide(1);   // swipe left = next
    else changeSlide(-1);           // swipe right = prev
  }
}, false);

// Handle hash on load
window.addEventListener('load', function() {
  const hash = window.location.hash;
  if (hash && hash.startsWith('#slide-')) {
    const n = parseInt(hash.replace('#slide-', ''));
    if (n >= 1 && n <= totalSlides) {
      showSlide(n);
      return;
    }
  }
  showSlide(1);
});
</script>

</body>
</html>