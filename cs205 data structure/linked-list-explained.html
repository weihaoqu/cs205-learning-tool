<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Singly Linked Lists - CS205 Data Structures</title>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: 'Segoe UI', system-ui, -apple-system, sans-serif; background: #0f172a; color: #e2e8f0; }
.slide { display: none; min-height: 100vh; padding: 40px 60px; position: relative; }
.slide.active { display: flex; flex-direction: column; justify-content: center; }
.slide-number { position: absolute; bottom: 20px; right: 40px; color: #64748b; font-size: 14px; }
.nav { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 12px; z-index: 100; }
.nav button { background: #334155; border: 1px solid #475569; color: #e2e8f0; padding: 8px 20px; border-radius: 8px; cursor: pointer; font-size: 14px; transition: all 0.2s; }
.nav button:hover { background: #475569; }
.nav button:disabled { opacity: 0.3; cursor: not-allowed; }
.progress { position: fixed; top: 0; left: 0; height: 3px; background: linear-gradient(90deg, #3b82f6, #8b5cf6); transition: width 0.3s; z-index: 100; }
h1 { font-size: 2.8em; margin-bottom: 20px; background: linear-gradient(135deg, #3b82f6, #8b5cf6); -webkit-background-clip: text; -webkit-text-fill-color: transparent; line-height: 1.2; }
h2 { font-size: 2em; margin-bottom: 16px; color: #93c5fd; }
h3 { font-size: 1.4em; margin-bottom: 12px; color: #a5b4fc; }
p, li { font-size: 1.15em; line-height: 1.7; color: #cbd5e1; margin-bottom: 10px; }
.subtitle { font-size: 1.3em; color: #94a3b8; margin-bottom: 30px; }
.two-col { display: grid; grid-template-columns: 1fr 1fr; gap: 40px; align-items: start; }
.center { text-align: center; }
.mt { margin-top: 20px; }
.diagram { background: #1e293b; border: 1px solid #334155; border-radius: 12px; padding: 24px; font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace; font-size: 1em; line-height: 1.6; white-space: pre; overflow-x: auto; margin: 16px 0; color: #a5f3fc; }
.diagram.small { font-size: 0.85em; }
.key-idea { background: linear-gradient(135deg, rgba(59,130,246,0.15), rgba(139,92,246,0.15)); border-left: 4px solid #3b82f6; border-radius: 0 12px 12px 0; padding: 20px 24px; margin: 16px 0; }
.key-idea h3 { margin-bottom: 8px; }
.warning { background: rgba(245,158,11,0.12); border-left: 4px solid #f59e0b; border-radius: 0 12px 12px 0; padding: 20px 24px; margin: 16px 0; }
.warning h3 { color: #fbbf24; }
.analogy { background: rgba(16,185,129,0.12); border-left: 4px solid #10b981; border-radius: 0 12px 12px 0; padding: 20px 24px; margin: 16px 0; }
.analogy h3 { color: #34d399; }
table { border-collapse: collapse; margin: 16px 0; width: auto; }
th, td { border: 1px solid #475569; padding: 10px 16px; text-align: center; }
th { background: #334155; color: #93c5fd; font-weight: 600; }
td { background: #1e293b; color: #e2e8f0; }
tr.highlight td { background: rgba(59,130,246,0.2); }
.fade-in { animation: fadeIn 0.5s ease-in; }
@keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
ul { padding-left: 24px; }
ul li { margin-bottom: 8px; }
code { background: #1e293b; padding: 2px 8px; border-radius: 4px; font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace; color: #a5f3fc; font-size: 0.95em; }
</style>
</head>
<body>

<div class="progress" id="progress"></div>

<!-- ==================== SLIDE 1: TITLE ==================== -->
<div class="slide active" id="s1">
  <div class="center">
    <h1>Singly Linked Lists</h1>
    <p class="subtitle">CS205 Data Structures</p>
    <div class="diagram" style="display:inline-block; text-align:left;">
   +---------+    +---------+    +---------+    +---------+
   | 10 | *--+--->| 20 | *--+--->| 30 | *--+--->| 40 |null|
   +---------+    +---------+    +---------+    +---------+
   ^
   |
  head
    </div>
    <p class="mt" style="color:#64748b;">Use arrow keys or buttons to navigate &bull; Press S for step reveals</p>
  </div>
  <div class="slide-number">1 / 20</div>
</div>

<!-- ==================== SLIDE 2: WHAT IS A LINKED LIST? ==================== -->
<div class="slide" id="s2">
  <h2>What is a Linked List?</h2>
  <p>A <strong>linked list</strong> is a linear data structure where each element (called a <strong>node</strong>) contains data and a reference (pointer) to the next node in the sequence.</p>

  <div class="diagram">
  Each node has two parts:

  +--------+--------+      +--------+--------+      +--------+--------+
  |  data  |  next  |----->|  data  |  next  |----->|  data  |  next  |----> null
  +--------+--------+      +--------+--------+      +--------+--------+

  "data" = the value stored        "next" = pointer to the next node
  </div>

  <div class="two-col mt">
    <div class="analogy">
      <h3>Analogy: Treasure Hunt</h3>
      <p>Imagine a treasure hunt where each clue tells you where to find the next clue. You can only follow the chain forward -- you cannot jump directly to clue #5. Each clue (node) has content (data) and directions to the next clue (pointer).</p>
    </div>
    <div class="analogy">
      <h3>Analogy: Train Cars</h3>
      <p>Think of a linked list as a train. Each car (node) carries cargo (data) and is coupled to the next car (next pointer). The engine is the <strong>head</strong>. The last car has no coupling -- it points to <code>null</code>.</p>
    </div>
  </div>

  <div class="key-idea mt">
    <h3>Key Idea</h3>
    <p>Unlike arrays, linked list nodes do NOT need to be stored contiguously in memory. They can be scattered anywhere -- the pointers connect them into a logical sequence.</p>
  </div>
  <div class="slide-number">2 / 20</div>
</div>

<!-- ==================== SLIDE 3: ARRAY VS LINKED LIST ==================== -->
<div class="slide" id="s3">
  <h2>Array vs. Linked List</h2>
  <div class="two-col">
    <div>
      <h3>Array: Contiguous Memory</h3>
      <div class="diagram small">
Memory addresses (contiguous):
 0x100  0x104  0x108  0x10C  0x110
+------+------+------+------+------+
|  10  |  20  |  30  |  40  |  50  |
+------+------+------+------+------+
  [0]    [1]    [2]    [3]    [4]

Direct access: arr[3] = go to 0x10C
      </div>
    </div>
    <div>
      <h3>Linked List: Scattered Memory</h3>
      <div class="diagram small">
Memory (scattered anywhere):
 0x200       0x580       0x340       0x710
+------+--+ +------+--+ +------+--+ +------+----+
|  10  | *-->|  20  | *-->|  30  | *-->|  40  |null|
+------+--+ +------+--+ +------+--+ +------+----+

Access [3]: must walk 0 -> 1 -> 2 -> 3
      </div>
    </div>
  </div>

  <table class="mt" style="width:100%;">
    <tr>
      <th>Operation</th>
      <th>Array</th>
      <th>Linked List</th>
      <th>Winner</th>
    </tr>
    <tr>
      <td>Access by index</td>
      <td>O(1)</td>
      <td>O(n)</td>
      <td>Array</td>
    </tr>
    <tr>
      <td>Insert at front</td>
      <td>O(n)</td>
      <td>O(1)</td>
      <td>Linked List</td>
    </tr>
    <tr>
      <td>Insert at end</td>
      <td>O(1)*</td>
      <td>O(n)</td>
      <td>Array</td>
    </tr>
    <tr>
      <td>Insert at middle</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>Tie</td>
    </tr>
    <tr>
      <td>Delete at front</td>
      <td>O(n)</td>
      <td>O(1)</td>
      <td>Linked List</td>
    </tr>
    <tr>
      <td>Search</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>Tie</td>
    </tr>
    <tr>
      <td>Memory overhead</td>
      <td>Low</td>
      <td>Higher (pointers)</td>
      <td>Array</td>
    </tr>
  </table>
  <p style="font-size:0.9em; color:#64748b;">* Amortized O(1) for dynamic arrays (ArrayList). Worst case O(n) when resizing.</p>
  <div class="slide-number">3 / 20</div>
</div>

<!-- ==================== SLIDE 4: THE NODE CLASS ==================== -->
<div class="slide" id="s4">
  <h2>The Node Class</h2>
  <p>Every linked list is built from <strong>Node</strong> objects. Each node stores one piece of data and one reference to the next node.</p>

  <div class="two-col mt">
    <div>
      <h3>Java Implementation</h3>
      <div class="diagram small">
public class Node {
    int data;       // the value stored
    Node next;      // pointer to next node

    // Constructor
    public Node(int data) {
        this.data = data;
        this.next = null;
    }
}
      </div>
      <p class="mt">The <code>next</code> field is itself a <code>Node</code> reference -- this is what creates the chain. When <code>next</code> is <code>null</code>, we have reached the end of the list.</p>
    </div>
    <div>
      <h3>Anatomy of a Single Node</h3>
      <div class="diagram">
  Node myNode = new Node(42);

  myNode
    |
    v
  +----------+-----------+
  | data: 42 | next: null|
  +----------+-----------+

  The node exists in memory,
  holding value 42 and pointing
  to nothing (null).
      </div>
      <div class="key-idea">
        <h3>Key Idea</h3>
        <p>A Node is a <strong>self-referential</strong> structure: it contains a reference to another object of its own type. This is the fundamental building block for all linked structures (lists, trees, graphs).</p>
      </div>
    </div>
  </div>
  <div class="slide-number">4 / 20</div>
</div>

<!-- ==================== SLIDE 5: SINGLY LINKED LIST STRUCTURE ==================== -->
<div class="slide" id="s5">
  <h2>Singly Linked List Structure</h2>
  <p>A singly linked list has three key properties: a <strong>head pointer</strong>, <strong>one-way traversal</strong>, and a <strong>null terminator</strong>.</p>

  <div class="diagram">
    head
     |
     v
  +------+---+    +------+---+    +------+---+    +------+------+
  |  10  | *-+--->|  20  | *-+--->|  30  | *-+--->|  40  | null |
  +------+---+    +------+---+    +------+---+    +------+------+

  Traversal direction: ============================>
  (one way only -- you CANNOT go backwards)
  </div>

  <div class="two-col mt">
    <div>
      <h3>Java Wrapper Class</h3>
      <div class="diagram small">
public class SinglyLinkedList {
    private Node head;  // entry point
    private int size;   // # of elements

    public SinglyLinkedList() {
        this.head = null;
        this.size = 0;
    }
}
      </div>
    </div>
    <div>
      <div class="key-idea">
        <h3>Three Things to Remember</h3>
        <ul>
          <li><strong>head</strong> -- the only entry point into the list. Lose it and you lose the entire list.</li>
          <li><strong>Singly linked</strong> -- each node only knows about the next node, never the previous one.</li>
          <li><strong>null terminator</strong> -- the last node's <code>next</code> is <code>null</code>, signaling the end.</li>
        </ul>
      </div>
    </div>
  </div>
  <div class="slide-number">5 / 20</div>
</div>

<!-- ==================== SLIDE 6: CREATING A LINKED LIST ==================== -->
<div class="slide" id="s6">
  <h2>Creating a Linked List (Step by Step)</h2>
  <p>Let's build the list <code>10 -> 20 -> 30</code> from scratch.</p>

  <div class="diagram small">
Step 1: Create first node, set head
  Node a = new Node(10);
  head = a;

  head
   |
   v
  +------+------+
  |  10  | null |
  +------+------+


Step 2: Create second node, link it
  Node b = new Node(20);
  a.next = b;

  head
   |
   v
  +------+---+    +------+------+
  |  10  | *-+--->|  20  | null |
  +------+---+    +------+------+


Step 3: Create third node, link it
  Node c = new Node(30);
  b.next = c;

  head
   |
   v
  +------+---+    +------+---+    +------+------+
  |  10  | *-+--->|  20  | *-+--->|  30  | null |
  +------+---+    +------+---+    +------+------+
  </div>

  <div class="warning">
    <h3>Warning: Never Lose the Head!</h3>
    <p>If you accidentally reassign <code>head</code> without saving the old reference, all nodes become unreachable and are lost (garbage collected in Java, leaked in C/C++).</p>
  </div>
  <div class="slide-number">6 / 20</div>
</div>

<!-- ==================== SLIDE 7: TRAVERSAL ==================== -->
<div class="slide" id="s7">
  <h2>Traversal</h2>
  <p>Walking through every node in the list using a temporary <code>current</code> pointer.</p>

  <div class="two-col">
    <div>
      <h3>Java Code</h3>
      <div class="diagram small">
public void printList() {
    Node current = head;
    while (current != null) {
        System.out.print(current.data + " -> ");
        current = current.next;
    }
    System.out.println("null");
}
      </div>
      <div class="key-idea mt">
        <h3>Key Idea</h3>
        <p>We use a <strong>temporary pointer</strong> (<code>current</code>) so we don't modify <code>head</code>. Moving <code>head</code> would lose access to the beginning of the list!</p>
      </div>
    </div>
    <div>
      <h3>Step-by-Step Visualization</h3>
      <div class="diagram small">
Iteration 1: current = node(10)
  [10|*]--->[20|*]--->[30|null]
   ^cur

Iteration 2: current = node(20)
  [10|*]--->[20|*]--->[30|null]
              ^cur

Iteration 3: current = node(30)
  [10|*]--->[20|*]--->[30|null]
                        ^cur

Iteration 4: current = null
  STOP. (while condition is false)

Output: 10 -> 20 -> 30 -> null
      </div>
    </div>
  </div>
  <div class="slide-number">7 / 20</div>
</div>

<!-- ==================== SLIDE 8: INSERT AT HEAD ==================== -->
<div class="slide" id="s8">
  <h2>Insert at Head -- O(1)</h2>
  <p>The fastest insertion: add a new node at the front of the list.</p>

  <div class="diagram small">
BEFORE: Insert 5 at head
  head
   |
   v
  +------+---+    +------+---+    +------+------+
  |  10  | *-+--->|  20  | *-+--->|  30  | null |
  +------+---+    +------+---+    +------+------+


Step 1: Create new node              Step 2: Point new node to old head
  newNode = new Node(5);              newNode.next = head;

  +------+------+     head            +------+---+     head
  |   5  | null |      |              |   5  | *-+--+   |
  +------+------+      v              +------+---+  |   v
                  [10|*]-->[20|*]-->[30|null]         +->[10|*]-->[20|*]-->[30|null]


Step 3: Move head to new node
  head = newNode;

  head
   |
   v
  +------+---+    +------+---+    +------+---+    +------+------+
  |   5  | *-+--->|  10  | *-+--->|  20  | *-+--->|  30  | null |
  +------+---+    +------+---+    +------+---+    +------+------+
  </div>

  <div class="two-col mt">
    <div class="diagram small">
public void insertAtHead(int data) {
    Node newNode = new Node(data);
    newNode.next = head;  // Step 2
    head = newNode;       // Step 3
    size++;
}
    </div>
    <div class="warning">
      <h3>Warning: Order Matters!</h3>
      <p><strong>WRONG:</strong> <code>head = newNode;</code> then <code>newNode.next = head;</code> -- this creates a self-loop! The new node points to itself and the rest of the list is lost forever.</p>
      <p><strong>RIGHT:</strong> Always link first (<code>newNode.next = head</code>), then move head.</p>
    </div>
  </div>
  <div class="slide-number">8 / 20</div>
</div>

<!-- ==================== SLIDE 9: INSERT AT TAIL ==================== -->
<div class="slide" id="s9">
  <h2>Insert at Tail -- O(n)</h2>
  <p>We must traverse the entire list to find the last node before we can append.</p>

  <div class="diagram small">
BEFORE: Insert 40 at tail
  head
   |
   v
  [10|*]--->[20|*]--->[30|null]


Step 1: Create new node
  newNode = new Node(40);       +------+------+
                                |  40  | null |
                                +------+------+

Step 2: Traverse to find last node
  current = head;
  while (current.next != null)
      current = current.next;
                                   current is now at node(30)

Step 3: Link last node to new node
  current.next = newNode;

AFTER:
  head
   |
   v
  [10|*]--->[20|*]--->[30|*]--->[40|null]
  </div>

  <div class="two-col mt">
    <div class="diagram small">
public void insertAtTail(int data) {
    Node newNode = new Node(data);
    if (head == null) {
        head = newNode;  // empty list
    } else {
        Node current = head;
        while (current.next != null) {
            current = current.next;
        }
        current.next = newNode;
    }
    size++;
}
    </div>
    <div class="key-idea">
      <h3>Why O(n)?</h3>
      <p>We have no direct reference to the tail, so we must walk all <em>n</em> nodes to find it. This is why some implementations also keep a <code>tail</code> pointer -- it makes tail insertion O(1).</p>
    </div>
  </div>
  <div class="slide-number">9 / 20</div>
</div>

<!-- ==================== SLIDE 10: INSERT AT POSITION ==================== -->
<div class="slide" id="s10">
  <h2>Insert at Position -- O(n)</h2>
  <p>Insert a new node at index <code>k</code> by finding the node at index <code>k-1</code> and rewiring pointers.</p>

  <div class="diagram small">
BEFORE: Insert 25 at index 2
  head      index 0    index 1    index 2
   |           |          |          |
   v           v          v          v
  [10|*]---->[20|*]---->[30|*]---->[40|null]


Step 1: Traverse to node at index 1 (the node BEFORE insertion point)
  prev = node at index 1 (value 20)

Step 2: Create new node and rewire
  newNode = new Node(25);
  newNode.next = prev.next;   // new node points to node(30)
  prev.next = newNode;        // node(20) now points to new node

AFTER:
  head
   |
   v
  [10|*]---->[20|*]---->[25|*]---->[30|*]---->[40|null]
                           ^
                       inserted here (index 2)
  </div>

  <div class="two-col mt">
    <div class="diagram small">
public void insertAt(int index, int data) {
    if (index == 0) {
        insertAtHead(data);
        return;
    }
    Node newNode = new Node(data);
    Node prev = head;
    for (int i = 0; i &lt; index - 1; i++) {
        prev = prev.next;
    }
    newNode.next = prev.next;  // link first!
    prev.next = newNode;       // then rewire
    size++;
}
    </div>
    <div class="warning">
      <h3>Warning: Order of Assignments</h3>
      <p><strong>WRONG:</strong> <code>prev.next = newNode;</code> first -- this breaks the chain and you lose access to everything after <code>prev</code>.</p>
      <p><strong>RIGHT:</strong> Always set <code>newNode.next</code> FIRST to preserve the rest of the chain, THEN update <code>prev.next</code>.</p>
    </div>
  </div>
  <div class="slide-number">10 / 20</div>
</div>

<!-- ==================== SLIDE 11: DELETE FROM HEAD ==================== -->
<div class="slide" id="s11">
  <h2>Delete from Head -- O(1)</h2>
  <p>Remove the first node by advancing the head pointer.</p>

  <div class="diagram small">
BEFORE:
  head
   |
   v
  +------+---+    +------+---+    +------+------+
  |  10  | *-+--->|  20  | *-+--->|  30  | null |
  +------+---+    +------+---+    +------+------+


Step 1: Save reference to old head (to return its data)
  Node removed = head;

Step 2: Advance head to next node
  head = head.next;

AFTER:
             head
               |
               v
  [10|*]-/->  +------+---+    +------+------+
  (orphan)    |  20  | *-+--->|  30  | null |
              +------+---+    +------+------+

  The old node(10) is now unreachable.
  In Java: garbage collector will reclaim it.
  In C/C++: you MUST call free(removed) or delete removed.
  </div>

  <div class="two-col mt">
    <div class="diagram small">
public int deleteFromHead() {
    if (head == null)
        throw new NoSuchElementException();
    int data = head.data;
    head = head.next;
    size--;
    return data;
}
    </div>
    <div class="key-idea">
      <h3>Memory Management</h3>
      <ul>
        <li><strong>Java / Python:</strong> Garbage collector automatically frees unreachable nodes.</li>
        <li><strong>C / C++:</strong> You must manually <code>free()</code> / <code>delete</code> the removed node, or you get a <strong>memory leak</strong>.</li>
      </ul>
    </div>
  </div>
  <div class="slide-number">11 / 20</div>
</div>

<!-- ==================== SLIDE 12: DELETE FROM TAIL ==================== -->
<div class="slide" id="s12">
  <h2>Delete from Tail -- O(n)</h2>
  <p>We must find the <strong>second-to-last</strong> node so we can set its <code>next</code> to <code>null</code>.</p>

  <div class="diagram small">
BEFORE: Delete last node (30)
  head
   |
   v
  [10|*]--->[20|*]--->[30|null]


Step 1: Traverse to second-to-last node
  current = head;
  while (current.next.next != null)
      current = current.next;

  current stops at node(20) because current.next.next == null

Step 2: Remove the last node
  current.next = null;

AFTER:
  head
   |
   v
  [10|*]--->[20|null]       [30] (orphaned, garbage collected)
  </div>

  <div class="two-col mt">
    <div class="diagram small">
public int deleteFromTail() {
    if (head == null)
        throw new NoSuchElementException();
    if (head.next == null) {
        // Only one node
        int data = head.data;
        head = null;
        size--;
        return data;
    }
    Node current = head;
    while (current.next.next != null) {
        current = current.next;
    }
    int data = current.next.data;
    current.next = null;
    size--;
    return data;
}
    </div>
    <div class="key-idea">
      <h3>Why Do We Need the Previous Node?</h3>
      <p>In a singly linked list, there is <strong>no backwards pointer</strong>. We cannot go from the last node to the second-to-last. So we must traverse from the head and stop <em>one node early</em>. This is why deletion from the tail is O(n), not O(1).</p>
      <p>A <strong>doubly linked list</strong> solves this by adding a <code>prev</code> pointer.</p>
    </div>
  </div>
  <div class="slide-number">12 / 20</div>
</div>

<!-- ==================== SLIDE 13: DELETE BY VALUE ==================== -->
<div class="slide" id="s13">
  <h2>Delete by Value -- O(n)</h2>
  <p>Find the node containing a specific value and remove it from the list.</p>

  <div class="diagram small">
BEFORE: Delete node with value 20
  head
   |
   v
  [10|*]--->[20|*]--->[30|*]--->[40|null]


Step 1: Traverse with TWO pointers (prev and current)
  prev = null,  current = head

  Iteration 1: current.data = 10, not 20.  prev = current, current = current.next
  Iteration 2: current.data = 20, FOUND!

  prev -> [10]    current -> [20]

Step 2: Bypass the target node
  prev.next = current.next;   // node(10) now points to node(30)

AFTER:
  head
   |
   v
  [10|*]--->[30|*]--->[40|null]

  node(20) is orphaned and garbage collected.
  </div>

  <div class="two-col mt">
    <div class="diagram small">
public boolean deleteByValue(int target) {
    if (head == null) return false;
    if (head.data == target) {
        head = head.next;
        size--;
        return true;
    }
    Node prev = head;
    Node current = head.next;
    while (current != null) {
        if (current.data == target) {
            prev.next = current.next;
            size--;
            return true;
        }
        prev = current;
        current = current.next;
    }
    return false;  // not found
}
    </div>
    <div class="key-idea">
      <h3>The Two-Pointer Technique</h3>
      <p>We maintain <code>prev</code> and <code>current</code> because to remove a node, we need to update the <strong>previous node's</strong> <code>next</code> pointer. We cannot go backwards in a singly linked list, so we track <code>prev</code> as we go.</p>
    </div>
  </div>
  <div class="slide-number">13 / 20</div>
</div>

<!-- ==================== SLIDE 14: SEARCH / CONTAINS ==================== -->
<div class="slide" id="s14">
  <h2>Search / Contains -- O(n)</h2>
  <p>Linear search through the list to find a value.</p>

  <div class="two-col">
    <div>
      <h3>Java Code</h3>
      <div class="diagram small">
public boolean contains(int target) {
    Node current = head;
    while (current != null) {
        if (current.data == target) {
            return true;   // found!
        }
        current = current.next;
    }
    return false;  // not in list
}


public int indexOf(int target) {
    Node current = head;
    int index = 0;
    while (current != null) {
        if (current.data == target) {
            return index;
        }
        current = current.next;
        index++;
    }
    return -1;  // not found
}
      </div>
    </div>
    <div>
      <h3>Searching for value 30</h3>
      <div class="diagram small">
  head
   |
   v
  [10|*]--->[20|*]--->[30|*]--->[40|null]
   ^
   cur: 10 == 30?  No.

  [10|*]--->[20|*]--->[30|*]--->[40|null]
              ^
              cur: 20 == 30?  No.

  [10|*]--->[20|*]--->[30|*]--->[40|null]
                        ^
                        cur: 30 == 30?  YES!
                        return true (index = 2)
      </div>

      <div class="key-idea mt">
        <h3>No Random Access</h3>
        <p>Unlike arrays where you can jump to <code>arr[i]</code> in O(1), a linked list requires you to start at the head and follow <code>next</code> pointers one by one. Searching is always <strong>O(n)</strong> in the worst case.</p>
      </div>
    </div>
  </div>
  <div class="slide-number">14 / 20</div>
</div>

<!-- ==================== SLIDE 15: GET SIZE / LENGTH ==================== -->
<div class="slide" id="s15">
  <h2>Get Size / Length</h2>
  <p>Two approaches: traverse and count, or maintain a <code>size</code> variable.</p>

  <div class="two-col">
    <div>
      <h3>Approach 1: Count by Traversal -- O(n)</h3>
      <div class="diagram small">
public int getSize() {
    int count = 0;
    Node current = head;
    while (current != null) {
        count++;
        current = current.next;
    }
    return count;
}
      </div>
      <div class="diagram small">
  [10|*]--->[20|*]--->[30|null]
   ^count=1   ^count=2   ^count=3
                          current=null -> return 3
      </div>
    </div>
    <div>
      <h3>Approach 2: Maintain Size Field -- O(1)</h3>
      <div class="diagram small">
public class SinglyLinkedList {
    private Node head;
    private int size;   // track it!

    public int getSize() {
        return size;    // O(1)!
    }

    public void insertAtHead(int data) {
        // ... insertion logic ...
        size++;   // increment on insert
    }

    public int deleteFromHead() {
        // ... deletion logic ...
        size--;   // decrement on delete
    }
}
      </div>
      <div class="key-idea">
        <h3>Best Practice</h3>
        <p>Always maintain a <code>size</code> field. Increment on every insert, decrement on every delete. This gives you O(1) size queries instead of O(n).</p>
      </div>
    </div>
  </div>
  <div class="slide-number">15 / 20</div>
</div>

<!-- ==================== SLIDE 16: SENTINEL / DUMMY NODE ==================== -->
<div class="slide" id="s16">
  <h2>Sentinel / Dummy Head Node</h2>
  <p>A dummy node at the front simplifies code by eliminating special cases for an empty list or inserting/deleting at the head.</p>

  <div class="diagram">
WITHOUT dummy (must check if head == null everywhere):

  head = null                          (empty list -- special case!)
  head -> [10|*] -> [20|null]          (insert at head -- special case!)


WITH dummy node (head is NEVER null):

  head
   |
   v
  +-------+---+    +------+---+    +------+------+
  | DUMMY | *-+--->|  10  | *-+--->|  20  | null |   (actual data starts AFTER dummy)
  +-------+---+    +------+---+    +------+------+

  Empty list with dummy:
  head
   |
   v
  +-------+------+
  | DUMMY | null |    (still have a head node -- no special case!)
  +-------+------+
  </div>

  <div class="two-col mt">
    <div class="diagram small">
// With dummy: insert at front
// No special case needed!
public void insertAtFront(int data) {
    Node newNode = new Node(data);
    newNode.next = head.next;
    head.next = newNode;
    size++;
}

// With dummy: delete by value
// No special case for head!
public boolean delete(int target) {
    Node prev = head;  // start at dummy
    Node cur = head.next;
    while (cur != null) {
        if (cur.data == target) {
            prev.next = cur.next;
            size--;
            return true;
        }
        prev = cur;
        cur = cur.next;
    }
    return false;
}
    </div>
    <div class="key-idea">
      <h3>Why Use a Sentinel?</h3>
      <ul>
        <li>The <code>head</code> pointer is <strong>never null</strong> -- no need to check <code>if (head == null)</code></li>
        <li>Inserting/deleting at the front follows the <strong>same logic</strong> as any other position</li>
        <li>Code is <strong>simpler and less error-prone</strong></li>
        <li>The dummy node holds no real data -- it is just a structural placeholder</li>
      </ul>
      <p class="mt">Trade-off: Uses one extra node of memory.</p>
    </div>
  </div>
  <div class="slide-number">16 / 20</div>
</div>

<!-- ==================== SLIDE 17: COMMON PITFALLS ==================== -->
<div class="slide" id="s17">
  <h2>Common Pitfalls</h2>
  <p>These are the bugs that trip up nearly every student the first time they implement a linked list.</p>

  <div class="two-col">
    <div>
      <div class="warning">
        <h3>1. NullPointerException</h3>
        <p>Calling <code>current.next</code> when <code>current</code> is <code>null</code>. Always check <code>current != null</code> before accessing its fields.</p>
      </div>

      <div class="warning">
        <h3>2. Losing References</h3>
        <p>Overwriting <code>head</code> or a <code>next</code> pointer before saving the old value. The rest of the list becomes unreachable.</p>
        <div class="diagram small" style="margin-top:8px;">
// BUG: Lost the rest of the list!
head = newNode;        // old head is gone
newNode.next = head;   // points to itself!

// FIX: Save before overwriting
newNode.next = head;   // preserve chain
head = newNode;        // now safe
        </div>
      </div>
    </div>
    <div>
      <div class="warning">
        <h3>3. Off-by-One Errors</h3>
        <p>When traversing to index <code>k</code>, you need to stop at index <code>k-1</code> for insertion. Using <code>&lt;</code> vs <code>&lt;=</code> in loop conditions is a common source of bugs.</p>
      </div>

      <div class="warning">
        <h3>4. Forgetting to Update Size</h3>
        <p>If you maintain a <code>size</code> field, every insert must <code>size++</code> and every delete must <code>size--</code>. One missed update corrupts all future size queries.</p>
      </div>

      <div class="warning">
        <h3>5. Not Handling Edge Cases</h3>
        <ul>
          <li>Empty list (<code>head == null</code>)</li>
          <li>Single-element list</li>
          <li>Deleting the head node</li>
          <li>Inserting at index 0</li>
        </ul>
      </div>
    </div>
  </div>
  <div class="slide-number">17 / 20</div>
</div>

<!-- ==================== SLIDE 18: TIME COMPLEXITY SUMMARY ==================== -->
<div class="slide" id="s18">
  <h2>Time Complexity Summary</h2>

  <table style="width:100%; margin-top:12px;">
    <tr>
      <th>Operation</th>
      <th>Singly Linked List</th>
      <th>Array (fixed)</th>
      <th>ArrayList (dynamic)</th>
    </tr>
    <tr class="highlight">
      <td>Insert at head</td>
      <td><strong>O(1)</strong></td>
      <td>O(n)</td>
      <td>O(n)</td>
    </tr>
    <tr>
      <td>Insert at tail</td>
      <td>O(n)*</td>
      <td>O(1)&#8224;</td>
      <td><strong>O(1) amortized</strong></td>
    </tr>
    <tr>
      <td>Insert at index k</td>
      <td>O(k)</td>
      <td>O(n)</td>
      <td>O(n)</td>
    </tr>
    <tr class="highlight">
      <td>Delete at head</td>
      <td><strong>O(1)</strong></td>
      <td>O(n)</td>
      <td>O(n)</td>
    </tr>
    <tr>
      <td>Delete at tail</td>
      <td>O(n)</td>
      <td>O(1)</td>
      <td><strong>O(1)</strong></td>
    </tr>
    <tr>
      <td>Delete by value</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(n)</td>
    </tr>
    <tr>
      <td>Access by index</td>
      <td>O(n)</td>
      <td><strong>O(1)</strong></td>
      <td><strong>O(1)</strong></td>
    </tr>
    <tr>
      <td>Search</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(n)</td>
    </tr>
    <tr>
      <td>Get size</td>
      <td>O(1)&#8225;</td>
      <td>O(1)</td>
      <td>O(1)</td>
    </tr>
  </table>

  <p style="font-size:0.9em; color:#64748b; margin-top:12px;">
    * O(1) if you maintain a tail pointer &nbsp;&nbsp;
    &#8224; Only if space available &nbsp;&nbsp;
    &#8225; If you maintain a size field
  </p>

  <div class="key-idea mt">
    <h3>When to Choose a Linked List</h3>
    <p>Use a linked list when you need <strong>frequent insertions/deletions at the head</strong>, don't need random access by index, and the data size is unpredictable. Use an array when you need <strong>fast random access</strong> and the size is relatively stable.</p>
  </div>
  <div class="slide-number">18 / 20</div>
</div>

<!-- ==================== SLIDE 19: REAL-WORLD APPLICATIONS ==================== -->
<div class="slide" id="s19">
  <h2>Real-World Applications</h2>

  <div class="two-col">
    <div>
      <h3>Implementing Stacks & Queues</h3>
      <div class="diagram small">
Stack (insert/delete at head):
  push(3): head->[3]->[2]->[1]->null
  pop():   head->[2]->[1]->null  (returned 3)

Queue (insert at tail, delete at head):
  enqueue(3): head->[1]->[2]->[3]->null
  dequeue():  head->[2]->[3]->null (returned 1)
      </div>

      <h3 class="mt">Music Playlist</h3>
      <div class="diagram small">
  [Song A] --> [Song B] --> [Song C] --> null
     ^
  currently
   playing

  "Next track" = advance the pointer
  "Add to queue" = insert at tail
  "Remove track" = delete by value
      </div>
    </div>
    <div>
      <h3>Undo Functionality</h3>
      <div class="diagram small">
  Each action is a node:
  head
   |
   v
  [action3] --> [action2] --> [action1]

  "Undo" = delete from head
  "New action" = insert at head
      </div>

      <h3 class="mt">Polynomial Representation</h3>
      <div class="diagram small">
  3x^4 + 2x^2 + 5

  [3,4] --> [2,2] --> [5,0] --> null
  coeff,exp  coeff,exp  coeff,exp

  Easy to add/remove terms!
      </div>

      <div class="analogy mt">
        <h3>Also Used In...</h3>
        <ul>
          <li>Operating system process scheduling</li>
          <li>Hash table chaining (collision resolution)</li>
          <li>Graph adjacency lists</li>
          <li>Memory allocation (free lists)</li>
        </ul>
      </div>
    </div>
  </div>
  <div class="slide-number">19 / 20</div>
</div>

<!-- ==================== SLIDE 20: SUMMARY & CHEAT SHEET ==================== -->
<div class="slide" id="s20">
  <h2>Summary & Cheat Sheet</h2>

  <div class="two-col">
    <div>
      <div class="diagram small">
  STRUCTURE:
  head -> [data|next] -> [data|next] -> null

  NODE CLASS:
  class Node {
      int data;
      Node next;
  }

  INSERT AT HEAD:        O(1)
    newNode.next = head;
    head = newNode;

  INSERT AT TAIL:        O(n)
    traverse to last node
    last.next = newNode;

  DELETE FROM HEAD:      O(1)
    head = head.next;

  DELETE FROM TAIL:      O(n)
    traverse to second-to-last
    secondToLast.next = null;

  SEARCH:                O(n)
    traverse, compare each node

  TRAVERSAL PATTERN:
    Node cur = head;
    while (cur != null) {
        // process cur.data
        cur = cur.next;
    }
      </div>
    </div>
    <div>
      <div class="key-idea">
        <h3>Golden Rules</h3>
        <ul>
          <li><strong>Never lose the head</strong> -- always use a temporary pointer for traversal.</li>
          <li><strong>Link before you redirect</strong> -- set <code>newNode.next</code> before updating <code>prev.next</code> or <code>head</code>.</li>
          <li><strong>Check for null</strong> -- before accessing <code>.data</code> or <code>.next</code>, make sure the node is not null.</li>
          <li><strong>Handle edge cases</strong> -- empty list, single element, head deletion.</li>
          <li><strong>Maintain size</strong> -- increment and decrement on every insert and delete.</li>
        </ul>
      </div>
      <div class="analogy mt">
        <h3>Train Cars Analogy Recap</h3>
        <p><strong>Engine</strong> = head pointer (entry point)</p>
        <p><strong>Each car</strong> = a node (carries cargo/data)</p>
        <p><strong>Coupling</strong> = next pointer (connects to next car)</p>
        <p><strong>Last car</strong> = points to null (end of train)</p>
        <p><strong>Insert</strong> = couple a new car in</p>
        <p><strong>Delete</strong> = uncouple a car, rejoin the remaining cars</p>
      </div>
      <div class="key-idea mt">
        <h3>Coming Next</h3>
        <p>Doubly Linked Lists -- adding a <code>prev</code> pointer to enable backward traversal and O(1) tail operations.</p>
      </div>
    </div>
  </div>
  <div class="slide-number">20 / 20</div>
</div>

<!-- NAVIGATION -->
<div class="nav">
  <button id="prevBtn" onclick="changeSlide(-1)">&larr; Prev</button>
  <button id="nextBtn" onclick="changeSlide(1)">Next &rarr;</button>
</div>

<script>
const totalSlides = 20;
let current = 1;
function showSlide(n) {
  document.querySelectorAll('.slide').forEach(s => s.classList.remove('active'));
  const slide = document.getElementById('s' + n);
  if (slide) { slide.classList.add('active'); slide.classList.add('fade-in'); }
  document.getElementById('prevBtn').disabled = (n === 1);
  document.getElementById('nextBtn').disabled = (n === totalSlides);
  document.getElementById('progress').style.width = ((n / totalSlides) * 100) + '%';
}
function changeSlide(delta) {
  const next = current + delta;
  if (next >= 1 && next <= totalSlides) { current = next; showSlide(current); }
}
document.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowRight' || e.key === 'ArrowDown' || e.key === ' ') { e.preventDefault(); changeSlide(1); }
  else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') { e.preventDefault(); changeSlide(-1); }
  else if (e.key === 's' || e.key === 'S') {
    const slide = document.getElementById('s' + current);
    const steps = slide.querySelectorAll('.step:not(.revealed)');
    if (steps.length > 0) steps[0].classList.add('revealed');
  }
});
showSlide(1);
</script>

</body>
</html>
